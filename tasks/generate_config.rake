## The MIT License (MIT)
##
## Copyright (c) 2014-2024
## Savin Max <mafei.198@gmail.com>
##
## Permission is hereby granted, free of charge, to any person obtaining a copy
## of this software and associated documentation files (the "Software"), to deal
## in the Software without restriction, including without limitation the rights
## to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
## copies of the Software, and to permit persons to whom the Software is
## furnished to do so, subject to the following conditions:
##
## The above copyright notice and this permission notice shall be included in all
## copies or substantial portions of the Software.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
## AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
## OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
## SOFTWARE.

class String
  def is_number?
    true if Float(self) rescue false
  end
end

desc "Generate configs Sql format file from Excel"
task :generate_config => :environment do
  config_dir = File.expand_path("#{FRAMEWORK_ROOT_DIR}/app/config_data/gameconfig")
  sheets = []

  Dir.foreach(config_dir) do |config_file_path|
    next if config_file_path =~ /~\$.+\.xls/
    extname = File.extname(config_file_path)
    if extname == '.xlsx'
      s = Roo::Excelx.new(File.expand_path(config_dir + '/' + config_file_path))
    elsif extname == '.xls'
      s = Roo::Excel.new(File.expand_path(config_dir + '/'+ config_file_path))
    else
      next
    end

    sql = ""

    s.sheets.each do |sheet|
      next if sheet !~ /^config_.+/
      sheets << sheet
    end

    s.sheets.each do |sheet|
      next if sheet !~ /^config_.+/
      s.default_sheet = sheet
      table_name = sheet.pluralize
      File.open("#{Rails.root.to_s}/app/models/#{sheet.singularize}.rb", 'w') do |io|
        model_name = sheet.singularize.camelize
        io.write "# Generated by generate_config.rake #{Time.now}\n"
        io.write "class #{model_name} < ActiveRecord::Base;end"
      end
      fields_define = []
      field_names = []
      field_indexes = {}
      s.row(2).each_with_index do |field, index|
        begin
          next if field.blank?
          name, type = field.split(":")
          field_indexes[index] = type
          field_names << name
          case type
          when 'string'
            fields_define << "`#{name}` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL"
          when 'text'
            fields_define << "`#{name}` text COLLATE utf8_unicode_ci"
          when 'integer'
            fields_define << "`#{name}` bigint(20) DEFAULT NULL"
          when 'float'
            fields_define << "`#{name}` float DEFAULT NULL"
          when 'boolean'
            fields_define << "`#{name}` boolean DEFAULT 0"
          else
            raise "TYPE ERROR: #{type} didn't defined."
          end
        rescue => e
          puts "In sheet: #{sheet}, field: #{field}"
          raise e
        end
      end
      # sql << %Q{
      #   DROP TABLE IF EXISTS `#{table_name}`;
      #   CREATE TABLE `#{table_name}` (
      #     `id` int(11) NOT NULL AUTO_INCREMENT,
      #     #{fields_define.join(",\n")},
      #     PRIMARY KEY (`id`)
      #   ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
      # }
      sql << %Q{
        DROP TABLE IF EXISTS `#{table_name}`;
        CREATE TABLE `#{table_name}` (
          #{fields_define.join(",\n")}
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
      }
      values = 4.upto(s.last_row).map do |row|
        row_values = []
        s.row(row).each_with_index do |value, index|
          next if field_indexes[index].nil?
          if ['string', 'text'].include?(field_indexes[index])
            value = ActiveRecord::Base.sanitize(value)
          end
          if field_indexes[index] == 'string' and value.is_number?
            value = value.to_i.to_s
          end
          value = 0 if field_indexes[index] == 'integer' and value.blank?
          value = 0.0 if field_indexes[index] == 'float' and value.blank?
          row_values << value
        end
        "(#{row_values.join(',')})"
      end.join(',')

      field_names = field_names.map do |field_name|
        "`#{field_name}`"
      end.join(',')

      sql << "INSERT INTO `#{table_name}` (#{field_names}) VALUES #{values};"
      file_path = "#{Rails.root.to_s}/db/config_data.sql"
      File.open(file_path, "w") do |io|
        io.write sql
      end
      database_name = Rails.configuration.database_configuration[Rails.env]["database"]

      # Make sure mysql path is: '/usr/bin/mysql'
      puts "Import sheet: #{sheet}"
      `mysql -u root #{database_name} < #{file_path}`
    end

    File.open("#{FRAMEWORK_ROOT_DIR}/game_server/include/config_names.hrl", 'w') do |io|
      io.puts "%%% Generated by generate_config.rake #{Time.now}\n"
      io.puts "-define(CONFIG_MODELS, [\n"
      io.puts "        #{sheets.map(&:pluralize).join(",\n        ")}"
      io.puts "        ])."
    end

    File.open("#{FRAMEWORK_ROOT_DIR}/app/generates/config_data.erl", 'w') do |io|
      io.puts "%%% Generated by generate_config.rake #{Time.now}\n"
      io.puts %Q{
-module(config_data).
-export([find/2, all/1, first/1, next_key/2]).

-define(MAP, #{config_maps})

get_tuple(Table) ->
    case lists:keyfind(Table, 1, ?MAP) of
        false -> [];
        {Table, Value} -> Value
    end.

find(Table, Key) ->
    case lists:keyfind(Key, 1, get_tuple(Table)) of
        false -> undefined;
        {Key, Value} -> Value
    end.

first(Table) ->
    case get_tuple(Table) of
        [] -> undefined;
        TupleList -> hd(TupleList)
    end.

all(Table) ->
    proplists:get_all_values(get_tuple(Table)).

next_key(Table, Key) ->
    TupleList = get_tuple(Table),
    Length = length(TupleList),
    next_key(TupleList, 1, Length, Key).

next_key(_, Index, Length, _) when Index > Length -> undefined;
next_key(TupleList, Index, Length, Key) ->
    {CurrentKey, _} = lists:nth(Index, TupleList),
    if
        CurrentKey =:= Key ->
            if
                Index < Length ->
                    lists:nth(Index + 1, TupleList);
                true ->
                    undefined
            end;
        true ->
            next_key(TupleList, Index + 1, Length, Key)
    end.
}
    end
  end
end
