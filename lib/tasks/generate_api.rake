## The MIT License (MIT)
##
## Copyright (c) 2014-2024
## Savin Max <mafei.198@gmail.com>
##
## Permission is hereby granted, free of charge, to any person obtaining a copy
## of this software and associated documentation files (the "Software"), to deal
## in the Software without restriction, including without limitation the rights
## to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
## copies of the Software, and to permit persons to whom the Software is
## furnished to do so, subject to the following conditions:
##
## The above copyright notice and this permission notice shall be included in all
## copies or substantial portions of the Software.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
## AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
## OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
## SOFTWARE.


desc "Generate API"
task :generate_api => :environment do
  api_path = "#{Rails.root.to_s}/api/request.yml"
  response_path = "#{Rails.root.to_s}/api/response.yml"
  routes_path = "#{Rails.root.to_s}/src/app/generates/routes.erl"
  request_encoder_path = "#{Rails.root.to_s}/src/app/generates/request_encoder.erl"
  request_decoder_path = "#{Rails.root.to_s}/src/app/generates/request_decoder.erl"
  response_encoder_path = "#{Rails.root.to_s}/src/app/generates/response_encoder.erl"
  response_decoder_path = "#{Rails.root.to_s}/src/app/generates/response_decoder.erl"

  api = YAML.load_file(api_path)
  response = YAML.load_file(response_path)

  header = ""
  header << "%%%===================================================================\n"
  header << "%%% Generated by generate_api.rb #{Time.now}\n"
  header << "%%%==================================================================="

  routes_content = %Q{#{header}
-module(routes).
-export([route/1]).
  }

  request_encoder_content = %Q{#{header}
-module(request_encoder).
-export([encode/2]).
  }

  request_decoder_content = %Q{#{header}
-module(request_decoder).
-export([decode/2]).

map([], [], Result) ->
    Result;
map([Key|Keys], [Value|Values], Result) ->
    map(Keys, Values, [{Key, Value}|Result]).

  }

  response_encoder_content = %Q{#{header}
-module(response_encoder).
-export([encode/2]).
  }

  response_decoder_content = %Q{#{header}
-module(response_decoder).
-export([decode/1]).
-include("include/protocol.hrl").
  }

  size = api.size
  api.each_with_index do |packet, idx|
    path, value = packet
    punctuation = (size - 1 == idx ? '.' : ';')

    controller, action = path.split('#')
    routes_content << %Q{
route(#{value['protocol_id']}) ->
    {#{controller}, #{action}}#{punctuation}}

    request_decoder_content << %Q{
decode(Bin, #{value['protocol_id']}) ->
    Keys = [#{value['attributes'].keys.join(',')}],
    Rule = {#{value['attributes'].values.join(',')}},
    Values = utils_protocol:decode(Bin, Rule),
    map(Keys, tuple_to_list(Values), [])#{punctuation}}

    list = ["utils_protocol:encode_short(Type)"]
    value['attributes'].each do |key, data_type|
      case data_type
      when 'string'
        list << "utils_protocol:encode_string(#{key.camelcase})"
      when 'integer'
        list << "utils_protocol:encode_integer(#{key.camelcase})"
      when 'float'
        list << "utils_protocol:encode_float(#{key.camelcase})"
      when 'short'
        list << "utils_protocol:encode_short(#{key.camelcase})"
      else
        type, element_name = data_type.split('-')
        raise "Wrong Data Type: #{type}" unless type == 'array'
        list << "utils_protocol:encode_array(#{key.camelcase}, fun(Item) -> request_encoder:encode(#{element_name}, Item) end)"
      end
    end

    request_encoder_content << %Q{
encode(<<"#{path}">>, Value) ->
    Type = #{value['protocol_id']},
    {#{value['attributes'].keys.map(&:camelcase).join(', ')}} = Value,
    DataList = [
#{list.map{|s|" " * 8 + s}.join(",\n")}
    ],
    list_to_binary(DataList)#{punctuation}}
  end

  size = response.size
  response.each_with_index do |packet, idx|
    response_name, value = packet
    punctuation = (size - 1 == idx ? '.' : ';')
    list = ["utils_protocol:encode_short(Type)"]
    decode_list = []
    value['attributes'].each_with_index do |attributes_packet, key_no|
      key, data_type = attributes_packet
      case data_type
      when 'string'
        list << "utils_protocol:encode_string(#{key.camelcase})"
        decode_list << "{#{key.camelcase}, Bin#{key_no+1}} = utils_protocol:decode_string(Bin#{key_no})"
      when 'integer'
        list << "utils_protocol:encode_integer(#{key.camelcase})"
        decode_list << "{#{key.camelcase}, Bin#{key_no+1}} = utils_protocol:decode_integer(Bin#{key_no})"
      when 'float'
        list << "utils_protocol:encode_float(#{key.camelcase})"
        decode_list << "{#{key.camelcase}, Bin#{key_no+1}} = utils_protocol:decode_float(Bin#{key_no})"
      when 'short'
        list << "utils_protocol:encode_short(#{key.camelcase})"
        decode_list << "{#{key.camelcase}, Bin#{key_no+1}} = utils_protocol:decode_short(Bin#{key_no})"
      else
        type, element_name = data_type.split('-')
        raise "Wrong Data Type: #{type}" unless type == 'array'
        list << "utils_protocol:encode_array(#{key.camelcase}, fun(Item) -> response_encoder:encode(#{element_name}, Item) end)"
        decode_list << "{#{key.camelcase}, Bin#{key_no+1}} = utils_protocol:decode_array(Bin#{key_no}, fun(Data) -> response_decoder:decode(Data) end)"
      end
    end
    response_encoder_content << %Q{
encode(#{response_name}, Value) ->
    Type = #{value['protocol_id']},
    {#{value['attributes'].keys.map(&:camelcase).join(', ')}} = Value,
    DataList = [
#{list.map{|s|" " * 8 + s}.join(",\n")}
    ],
    list_to_binary(DataList)#{punctuation}}

    response_decoder_content << %Q{
decode(<<#{value['protocol_id']}:?SHORT, Bin0>>) ->
    #{decode_list.join(",\n    ")},
    {[#{value['attributes'].keys.map{|key| "{#{key}, #{key.camelcase}}"}.join(", ")}], Bin#{value['attributes'].keys.size}}#{punctuation}}
  end

  File.open(routes_path, 'w'){|io| io.write routes_content}
  File.open(request_encoder_path, 'w'){|io| io.write request_encoder_content}
  File.open(request_decoder_path, 'w'){|io| io.write request_decoder_content}
  File.open(response_encoder_path, 'w'){|io| io.write response_encoder_content}
  File.open(response_decoder_path, 'w'){|io| io.write response_decoder_content}
end
